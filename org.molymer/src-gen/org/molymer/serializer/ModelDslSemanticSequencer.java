/*
 * generated by Xtext
 */
package org.molymer.serializer;

import com.google.inject.Inject;
import com.google.inject.Provider;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.serializer.acceptor.ISemanticSequenceAcceptor;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.diagnostic.ISemanticSequencerDiagnosticProvider;
import org.eclipse.xtext.serializer.diagnostic.ISerializationDiagnostic.Acceptor;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.GenericSequencer;
import org.eclipse.xtext.serializer.sequencer.ISemanticNodeProvider.INodesForEObjectProvider;
import org.eclipse.xtext.serializer.sequencer.ISemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.molymer.modelDsl.Annotation;
import org.molymer.modelDsl.AnnotationGroup;
import org.molymer.modelDsl.AnnotationHiddenProperty;
import org.molymer.modelDsl.AnnotationInstance;
import org.molymer.modelDsl.AnnotationProperty;
import org.molymer.modelDsl.AnnotationType;
import org.molymer.modelDsl.Child;
import org.molymer.modelDsl.ChildType;
import org.molymer.modelDsl.DataType;
import org.molymer.modelDsl.DataTypeField;
import org.molymer.modelDsl.DataTypeType;
import org.molymer.modelDsl.DoubleValue;
import org.molymer.modelDsl.Entity;
import org.molymer.modelDsl.EntityElements;
import org.molymer.modelDsl.EntityGroup;
import org.molymer.modelDsl.EntityType;
import org.molymer.modelDsl.FormatRangeValue;
import org.molymer.modelDsl.GroupType;
import org.molymer.modelDsl.Import;
import org.molymer.modelDsl.IntegerValue;
import org.molymer.modelDsl.Model;
import org.molymer.modelDsl.ModelDslPackage;
import org.molymer.modelDsl.PackageType;
import org.molymer.modelDsl.Parent;
import org.molymer.modelDsl.ParentType;
import org.molymer.modelDsl.PatternType;
import org.molymer.modelDsl.Property;
import org.molymer.modelDsl.PropertyType;
import org.molymer.modelDsl.RangeValue;
import org.molymer.modelDsl.Reference;
import org.molymer.modelDsl.ReferenceList;
import org.molymer.modelDsl.ReferenceListType;
import org.molymer.modelDsl.ReferenceType;
import org.molymer.modelDsl.StringValue;
import org.molymer.services.ModelDslGrammarAccess;

@SuppressWarnings("all")
public class ModelDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ModelDslGrammarAccess grammarAccess;
	
	@Override
	public void createSequence(EObject context, EObject semanticObject) {
		if(semanticObject.eClass().getEPackage() == ModelDslPackage.eINSTANCE) switch(semanticObject.eClass().getClassifierID()) {
			case ModelDslPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case ModelDslPackage.ANNOTATION_GROUP:
				sequence_AnnotationGroup(context, (AnnotationGroup) semanticObject); 
				return; 
			case ModelDslPackage.ANNOTATION_HIDDEN_PROPERTY:
				sequence_AnnotationHiddenProperty(context, (AnnotationHiddenProperty) semanticObject); 
				return; 
			case ModelDslPackage.ANNOTATION_INSTANCE:
				sequence_AnnotationInstance(context, (AnnotationInstance) semanticObject); 
				return; 
			case ModelDslPackage.ANNOTATION_PROPERTY:
				if(context == grammarAccess.getAnnotationMandatoryPropertyRule()) {
					sequence_AnnotationMandatoryProperty(context, (AnnotationProperty) semanticObject); 
					return; 
				}
				else if(context == grammarAccess.getAnnotationOptionalPropertyRule()) {
					sequence_AnnotationOptionalProperty(context, (AnnotationProperty) semanticObject); 
					return; 
				}
				else break;
			case ModelDslPackage.ANNOTATION_TYPE:
				sequence_AnnotationType(context, (AnnotationType) semanticObject); 
				return; 
			case ModelDslPackage.CHILD:
				sequence_Child(context, (Child) semanticObject); 
				return; 
			case ModelDslPackage.CHILD_TYPE:
				sequence_ChildType(context, (ChildType) semanticObject); 
				return; 
			case ModelDslPackage.DATA_TYPE:
				sequence_DataType(context, (DataType) semanticObject); 
				return; 
			case ModelDslPackage.DATA_TYPE_FIELD:
				sequence_DataTypeField(context, (DataTypeField) semanticObject); 
				return; 
			case ModelDslPackage.DATA_TYPE_TYPE:
				sequence_DataTypeType(context, (DataTypeType) semanticObject); 
				return; 
			case ModelDslPackage.DOUBLE_VALUE:
				sequence_DoubleValue(context, (DoubleValue) semanticObject); 
				return; 
			case ModelDslPackage.ENTITY:
				sequence_Entity(context, (Entity) semanticObject); 
				return; 
			case ModelDslPackage.ENTITY_ELEMENTS:
				sequence_EntityElements(context, (EntityElements) semanticObject); 
				return; 
			case ModelDslPackage.ENTITY_GROUP:
				sequence_EntityGroup(context, (EntityGroup) semanticObject); 
				return; 
			case ModelDslPackage.ENTITY_TYPE:
				sequence_EntityType(context, (EntityType) semanticObject); 
				return; 
			case ModelDslPackage.FORMAT_RANGE_VALUE:
				sequence_FormatRangeValue(context, (FormatRangeValue) semanticObject); 
				return; 
			case ModelDslPackage.GROUP_TYPE:
				sequence_GroupType(context, (GroupType) semanticObject); 
				return; 
			case ModelDslPackage.IMPORT:
				sequence_Import(context, (Import) semanticObject); 
				return; 
			case ModelDslPackage.INTEGER_VALUE:
				sequence_IntegerValue(context, (IntegerValue) semanticObject); 
				return; 
			case ModelDslPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ModelDslPackage.PACKAGE:
				sequence_Package(context, (org.molymer.modelDsl.Package) semanticObject); 
				return; 
			case ModelDslPackage.PACKAGE_TYPE:
				sequence_PackageType(context, (PackageType) semanticObject); 
				return; 
			case ModelDslPackage.PARENT:
				sequence_Parent(context, (Parent) semanticObject); 
				return; 
			case ModelDslPackage.PARENT_TYPE:
				sequence_ParentType(context, (ParentType) semanticObject); 
				return; 
			case ModelDslPackage.PATTERN_TYPE:
				sequence_PatternType(context, (PatternType) semanticObject); 
				return; 
			case ModelDslPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case ModelDslPackage.PROPERTY_TYPE:
				sequence_PropertyType(context, (PropertyType) semanticObject); 
				return; 
			case ModelDslPackage.RANGE_VALUE:
				sequence_RangeValue(context, (RangeValue) semanticObject); 
				return; 
			case ModelDslPackage.REFERENCE:
				sequence_Reference(context, (Reference) semanticObject); 
				return; 
			case ModelDslPackage.REFERENCE_LIST:
				sequence_ReferenceList(context, (ReferenceList) semanticObject); 
				return; 
			case ModelDslPackage.REFERENCE_LIST_TYPE:
				sequence_ReferenceListType(context, (ReferenceListType) semanticObject); 
				return; 
			case ModelDslPackage.REFERENCE_TYPE:
				sequence_ReferenceType(context, (ReferenceType) semanticObject); 
				return; 
			case ModelDslPackage.STRING_VALUE:
				sequence_StringValue(context, (StringValue) semanticObject); 
				return; 
			}
		if (errorAcceptor != null) errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Constraint:
	 *     instances+=AnnotationInstance+
	 */
	protected void sequence_AnnotationGroup(EObject context, AnnotationGroup semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (property=[AnnotationProperty|ID] values+=[AnnotationValue|ID]*)
	 */
	protected void sequence_AnnotationHiddenProperty(EObject context, AnnotationHiddenProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (annotation=[Annotation|QualifiedName] values+=AnnotationValue* properties+=AnnotationHiddenProperty*)
	 */
	protected void sequence_AnnotationInstance(EObject context, AnnotationInstance semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (group=GroupType | (type=ValueType multi?='*'?)))
	 */
	protected void sequence_AnnotationMandatoryProperty(EObject context, AnnotationProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID (group=GroupType | (type=ValueType multi?='*'?)))
	 */
	protected void sequence_AnnotationOptionalProperty(EObject context, AnnotationProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type='#annotation'
	 */
	protected void sequence_AnnotationType(EObject context, AnnotationType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getAnnotationTypeAccess().getTypeAnnotationKeyword_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (types+=AnnoTypes+ instances+=AnnotationInstance* name=ID mandatories+=AnnotationMandatoryProperty* optionals+=AnnotationOptionalProperty*)
	 */
	protected void sequence_Annotation(EObject context, Annotation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type='#child'
	 */
	protected void sequence_ChildType(EObject context, ChildType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getChildTypeAccess().getTypeChildKeyword_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=[Entity|QualifiedName] annotations+=AnnotationGroup*)
	 */
	protected void sequence_Child(EObject context, Child semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((pattern=PatternType format=PATTERN_STRING) | type=[DataType|QualifiedName])
	 */
	protected void sequence_DataTypeField(EObject context, DataTypeField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type='#datatype'
	 */
	protected void sequence_DataTypeType(EObject context, DataTypeType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDataTypeTypeAccess().getTypeDatatypeKeyword_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (annotations+=AnnotationGroup* name=ID formatedFields+=DataTypeField*)
	 */
	protected void sequence_DataType(EObject context, DataType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=Double
	 */
	protected void sequence_DoubleValue(EObject context, DoubleValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.DOUBLE_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.DOUBLE_VALUE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getDoubleValueAccess().getValueDoubleParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (childs+=Child* properties+=Property* references+=Reference* referenceLists+=ReferenceList*)
	 */
	protected void sequence_EntityElements(EObject context, EntityElements semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID elements=EntityElements)
	 */
	protected void sequence_EntityGroup(EObject context, EntityGroup semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ENTITY_GROUP__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ENTITY_GROUP__NAME));
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ENTITY_GROUP__ELEMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ENTITY_GROUP__ELEMENTS));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEntityGroupAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEntityGroupAccess().getElementsEntityElementsParserRuleCall_3_0(), semanticObject.getElements());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     type='#entity'
	 */
	protected void sequence_EntityType(EObject context, EntityType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getEntityTypeAccess().getTypeEntityKeyword_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (annotations+=AnnotationGroup* name=ID parent=Parent? elements=EntityElements groups+=EntityGroup*)
	 */
	protected void sequence_Entity(EObject context, Entity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (from=STRING to=STRING)
	 */
	protected void sequence_FormatRangeValue(EObject context, FormatRangeValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.FORMAT_RANGE_VALUE__FROM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.FORMAT_RANGE_VALUE__FROM));
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.FORMAT_RANGE_VALUE__TO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.FORMAT_RANGE_VALUE__TO));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getFormatRangeValueAccess().getFromSTRINGTerminalRuleCall_0_0(), semanticObject.getFrom());
		feeder.accept(grammarAccess.getFormatRangeValueAccess().getToSTRINGTerminalRuleCall_2_0(), semanticObject.getTo());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type='#group' name=STRING)
	 */
	protected void sequence_GroupType(EObject context, GroupType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.GROUP_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.GROUP_TYPE__NAME));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getGroupTypeAccess().getTypeGroupKeyword_0_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getGroupTypeAccess().getNameSTRINGTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 */
	protected void sequence_Import(EObject context, Import semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.IMPORT__IMPORTED_NAMESPACE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getImportAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     value=Integer
	 */
	protected void sequence_IntegerValue(EObject context, IntegerValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.INTEGER_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.INTEGER_VALUE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getIntegerValueAccess().getValueIntegerParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (imports+=Import* elements+=Element*)
	 */
	protected void sequence_Model(EObject context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type='#package'
	 */
	protected void sequence_PackageType(EObject context, PackageType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPackageTypeAccess().getTypePackageKeyword_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (annotations+=AnnotationGroup* name=ID elements+=Element*)
	 */
	protected void sequence_Package(EObject context, org.molymer.modelDsl.Package semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type='#parent'
	 */
	protected void sequence_ParentType(EObject context, ParentType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getParentTypeAccess().getTypeParentKeyword_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (type=[Entity|QualifiedName] annotations+=AnnotationGroup*)
	 */
	protected void sequence_Parent(EObject context, Parent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     (REGEX='@regex' | DATE='@date' | NUMBER='@number')
	 */
	protected void sequence_PatternType(EObject context, PatternType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type='#property'
	 */
	protected void sequence_PropertyType(EObject context, PropertyType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getPropertyTypeAccess().getTypePropertyKeyword_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID optional?='?'? type=[Type|QualifiedName] annotations+=AnnotationGroup*)
	 */
	protected void sequence_Property(EObject context, Property semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     ((from=Integer | fromInf?='*') (to=Integer | toInf?='*'))
	 */
	protected void sequence_RangeValue(EObject context, RangeValue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type='#reference-list'
	 */
	protected void sequence_ReferenceListType(EObject context, ReferenceListType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReferenceListTypeAccess().getTypeReferenceListKeyword_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID reference=[Reference|ID]? entity=[Entity|QualifiedName] annotations+=AnnotationGroup*)
	 */
	protected void sequence_ReferenceList(EObject context, ReferenceList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     type='#reference'
	 */
	protected void sequence_ReferenceType(EObject context, ReferenceType semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.ANNO_TYPES__TYPE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getReferenceTypeAccess().getTypeReferenceKeyword_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * Constraint:
	 *     (name=ID optional?='?'? entity=[Entity|QualifiedName] annotations+=AnnotationGroup*)
	 */
	protected void sequence_Reference(EObject context, Reference semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringValue(EObject context, StringValue semanticObject) {
		if(errorAcceptor != null) {
			if(transientValues.isValueTransient(semanticObject, ModelDslPackage.Literals.STRING_VALUE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelDslPackage.Literals.STRING_VALUE__VALUE));
		}
		INodesForEObjectProvider nodes = createNodeProvider(semanticObject);
		SequenceFeeder feeder = createSequencerFeeder(semanticObject, nodes);
		feeder.accept(grammarAccess.getStringValueAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
}
