/*
 * generated by Xtext
 */
package org.molymer.validation

import com.google.inject.Inject
import org.eclipse.xtext.validation.Check
import java.util.Iterator
import java.util.HashSet
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.emf.ecore.EObject
import org.molymer.modelDsl.Model
import org.molymer.modelDsl.ModelDslPackage
import org.molymer.modelDsl.ModelDslFactory
import org.molymer.modelDsl.Element
import org.molymer.modelDsl.AnnotationInstance
import org.molymer.modelDsl.ValueType
import org.molymer.modelDsl.AnnotationGroup
import org.molymer.modelDsl.AnnotationValue
import org.molymer.modelDsl.AnnotationProperty
import org.molymer.modelDsl.Field
import org.molymer.modelDsl.StringValue
import org.molymer.modelDsl.IntegerValue
import org.molymer.modelDsl.RangeValue
import org.molymer.modelDsl.DataType
import org.molymer.modelDsl.Annotation
import org.molymer.modelDsl.Entity
import org.molymer.modelDsl.Property
import org.molymer.modelDsl.Parent
import org.molymer.modelDsl.Child
import org.molymer.modelDsl.Reference
import org.molymer.modelDsl.ReferenceList
import org.molymer.modelDsl.Annotated
import org.molymer.modelDsl.GroupType
import org.molymer.modelDsl.FormatRangeValue
import org.molymer.modelDsl.PackageType
import org.molymer.modelDsl.DataTypeType
import org.molymer.modelDsl.EntityType
import org.molymer.modelDsl.PropertyType
import org.molymer.modelDsl.ReferenceType
import org.molymer.modelDsl.ParentType
import org.molymer.modelDsl.ChildType
import org.molymer.modelDsl.ReferenceListType
import org.molymer.modelDsl.AnnotationType
import org.molymer.modelDsl.Package
import org.molymer.modelDsl.DoubleValue

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class ModelDslValidator extends AbstractModelDslValidator {

	@Inject extension IQualifiedNameProvider

	@Check
	def uniqueElement(Model model) {
		val uniqueSet = new HashSet<String>
		model.eAllContents.filter(Element).forEach[
			val fName = fullyQualifiedName.toString
			if(uniqueSet.contains(fName)) {
				error("Element names have to be unique", it, ModelDslPackage.Literals.ELEMENT__NAME)
			} else {
				uniqueSet.add(fName)
			}
		]
	}
	
	@Check
	def uniqueEntityField(Entity entity) {
		val uniqueSet = new HashSet<String>
		entity.eAllContents.filter(Field).forEach[
			if(uniqueSet.contains(name)) {
				error("Field names have to be unique", it, ModelDslPackage.Literals.FIELD__NAME)
			} else {
				uniqueSet.add(name)
			}
		]
	}
	
	@Check
	def uniqueEntityChilds(Entity entity) {
		val uniqueSet = new HashSet<Entity>
		entity.eAllContents.filter(Child).forEach[
			if(type != null) {
				if(uniqueSet.contains(type)) {
					error("Child references chould be unique, already exists reference to: " + type.fullyQualifiedName, it, ModelDslPackage.Literals.CONTAINER__TYPE)
				} else {
					uniqueSet.add(type)
				}
			}
		]
	}
	
	@Check
	def uniqueEntityReferenceList(Entity entity) {
		val uniqueSet = new HashSet<String>
		entity.eAllContents.filter(ReferenceList).forEach[
			if(reference != null) {
				val refName = it.entity.fullyQualifiedName.toString + "." + reference.name
				if(uniqueSet.contains(refName)) {
					error("Inverted references chould be unique, already exists: " + refName, it, ModelDslPackage.Literals.FIELD__NAME)
				} else {
					uniqueSet.add(refName)
				}
			}
		]		
	}
	
	@Check
	def uniqueAnnotationProperty(Annotation annon) {
		val uniqueSet = new HashSet<String>
		annon.eContents.filter(AnnotationProperty).forEach[
			if(uniqueSet.contains(name)) {
				error("Property names have to be unique", it, ModelDslPackage.Literals.ANNOTATION_PROPERTY__NAME)
			} else {
				uniqueSet.add(name)
			}
		]
	}
		
	@Check
	def range(RangeValue range) {
		if(!range.fromInf && !range.toInf && range.from > range.to) {
			error("Range interval incorrect", ModelDslPackage.Literals.RANGE_VALUE__FROM)
		}
	}
	
	@Check
	def annotationInstance(AnnotationInstance instance) {
		
		//validate annotation parameters-------------------------------------------------------------------------------------------------------------------------
		var iterValues = instance.values.iterator
		for(prop: instance.annotation.mandatories) {
			if(!iterValues.hasNext) {
				error("No value for mandatory property: " + prop.name, ModelDslPackage.Literals.ANNOTATION_INSTANCE__ANNOTATION)
				return;
			}
			
			iterValues = instance.validateAnnotationValues(iterValues, prop);
			if(iterValues == null) return;
		}
		
		for(prop: instance.annotation.optionals) {
			if(iterValues.hasNext) {
				iterValues = instance.validateAnnotationValues(iterValues, prop);
				if(iterValues == null) return;
			}
		}
		
		//all parameters should be consumed----------------------------------------------------------------------------------------------------------------------
		if(iterValues.hasNext) {
			error("No property in '" + instance.annotation.fullyQualifiedName + "' for last value" , ModelDslPackage.Literals.ANNOTATION_INSTANCE__ANNOTATION)
			return;
		}
		
		//validate annotation containers-------------------------------------------------------------------------------------------------------------------------
		val containerObj = instance.annotatedObject
		val containerType = containerObj.annotatedType
		
		if(containerType == GroupType) {
			val annContainer = containerObj as AnnotationInstance
			
			//get the mapped property for AnnotationGroup parent...
			val hiddenProp = annContainer.getPropertyOf(instance.eContainer)
			val gType = instance.annotation.getTypeOf(GroupType)
			if(gType.name != hiddenProp.property.group.name) {
				error("Annotation '" + instance.annotation.name + "' is not on the group: " + gType.name, ModelDslPackage.Literals.ANNOTATION_INSTANCE__ANNOTATION)
				return;
			}
			
		} else {
			val fResult = instance.annotation.types.filter(containerType)
			if(fResult.empty) {
				error("Element " + containerType.simpleName + " can't have annotation: " + instance.annotation.fullyQualifiedName, ModelDslPackage.Literals.ANNOTATION_INSTANCE__ANNOTATION)
				return;
			}
		}
	}
	
	def <T> getTypeOf(Annotation anno, Class<T> type) {
		val resultFilter = anno.types.filter(type)
		if(resultFilter.empty) {
			println("not found: " + anno.name + " -> " + type.simpleName)
		}
		
		return anno.types.filter(type).get(0);
	}
	
	def getPropertyOf(AnnotationInstance instance, Object value) {
		return instance.properties.findFirst[values.exists[it == value]]
	}
	
	def validateAnnotationValues(AnnotationInstance instance, Iterator<AnnotationValue> iterValues, AnnotationProperty prop) {
		val pValue = iterValues.next
		if(!isSameType(pValue, prop)) {
			error("Invalid type for property: " + prop.name, ModelDslPackage.Literals.ANNOTATION_INSTANCE__ANNOTATION)
			return null;
		}
		
		//complete hidden properties...
		instance.addHiddenProperty(prop, pValue)
		
		//verify until reach diferent type!
		if(prop.multi)
			return instance.consumeArrays(iterValues, prop)
		
		return iterValues
	}
	
	def getAnnotatedType(EObject obj) {
		if(obj instanceof Package)
			return PackageType
		
		if(obj instanceof DataType) 
			return DataTypeType
		
		if(obj instanceof Annotation)
			return AnnotationType
		
		if(obj instanceof Entity)
			return EntityType
		
		
		if(obj instanceof AnnotationInstance)
			return GroupType
		
				
		if(obj instanceof Property)
			return PropertyType
		
		if(obj instanceof Reference)
			return ReferenceType

		if(obj instanceof ReferenceList)
			return ReferenceListType
		
		
		if(obj instanceof Parent)
			return ParentType
		
		if(obj instanceof Child)
			return ChildType
	}
	
	def getAnnotatedObject(AnnotationInstance instance) {
		var EObject top = instance
		
		do {
			top = top.eContainer
		} while(!(top instanceof Annotated))
		
		return top
	}
	
	def void addHiddenProperty(AnnotationInstance instance, AnnotationProperty prop, AnnotationValue value) {
		val hiddenProperty = ModelDslFactory.eINSTANCE.createAnnotationHiddenProperty
		hiddenProperty.property = prop
		hiddenProperty.values += value
		instance.properties.add(hiddenProperty);
	}
	
	def consumeArrays(AnnotationInstance instance, Iterator<AnnotationValue> iterValues, AnnotationProperty prop) {
		return iterValues.dropWhile[
			val isTrue = isSameType(it, prop)
			if(isTrue)
				instance.addHiddenProperty(prop, it)
			return isTrue
		]
	}
	
	def isSameType(AnnotationValue annValue, AnnotationProperty prop) {
		if(
			annValue instanceof StringValue && prop.type != ValueType.STRING 			||
			annValue instanceof IntegerValue && prop.type != ValueType.INTEGER			||
			annValue instanceof DoubleValue && prop.type != ValueType.DOUBLE			||
			annValue instanceof RangeValue && prop.type != ValueType.INT_RANGE			||
			annValue instanceof FormatRangeValue && prop.type != ValueType.FORMAT_RANGE ||
			annValue instanceof AnnotationGroup && !(prop.group instanceof GroupType)
		)
			return false
			
		return true
	}
}
